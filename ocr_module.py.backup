"""
ocr_module.py – Enhanced Tesseract OCR (Stage 1 - No LLM)
----------------------------------------------------------
High-precision Tesseract OCR with advanced image preprocessing.
Designed for Dell XPS 14 9440, HIPAA compliant (100% local).

This is Stage 1: Get Tesseract working well.
Stage 2: Add Ollama LLM for even better accuracy.

Features:
- Multi-pass OCR with different preprocessing strategies
- Image enhancement (scaling, contrast, denoising)
- Intelligent field extraction with context awareness
- Self-validation and cross-checking

Author: Insurance Claim Automation Team
Version: 8.0 - Enhanced Tesseract (Pre-LLM)
"""

import os
import re
import logging
from typing import Dict, List, Tuple, Optional
import pytesseract
from PIL import Image, ImageEnhance, ImageFilter
import cv2
import numpy as np

# Configure logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)


def extract_claim(image_path: str, lang: str = 'eng') -> Dict[str, str]:
    """
    Main entry point: Extract structured claim data from ERA screenshot.
    
    Uses multi-pass OCR with different preprocessing strategies for maximum accuracy.
    
    Args:
        image_path: Path to ERA screenshot image file
        lang: Language for OCR (default: 'eng')
        
    Returns:
        Dictionary with structured claim fields
    """
    
    if not os.path.exists(image_path):
        logger.error(f"⚠️ File not found: {image_path}")
        return _empty_data()
    
    try:
        logger.info(f"Running Enhanced Tesseract OCR on {os.path.basename(image_path)}...")
        
        # Load image
        img = Image.open(image_path)
        
        # === MULTI-PASS OCR STRATEGY ===
        # We run OCR 3 times with different preprocessing to catch everything
        
        # Pass 1: High contrast (best for amounts and codes)
        text1 = _ocr_pass_1_high_contrast(img)
        
        # Pass 2: Grayscale with denoising (best for text)
        text2 = _ocr_pass_2_denoised(img)
        
        # Pass 3: Adaptive threshold (best for varied lighting)
        text3 = _ocr_pass_3_adaptive(img)
        
        # Combine all passes (longest text usually best)
        all_texts = [text1, text2, text3]
        raw_text = max(all_texts, key=len)
        
        # Also keep all texts for cross-validation
        combined_text = "\n".join(all_texts)
        
        logger.info(f"✅ OCR extracted {len(raw_text)} characters (best pass)")
        logger.info(f"   Total from all passes: {len(combined_text)} characters")
        
        # Debug: Log extracted text
        logger.info(f"\n--- RAW OCR TEXT (First 500 chars) ---")
        logger.info(raw_text[:500])
        logger.info(f"--- END RAW TEXT ---\n")
        
        # === PARSE AND STRUCTURE DATA ===
        parsed_data = _parse_era_text(raw_text, combined_text)
        
        # === SELF-VALIDATION ===
        parsed_data = _validate_and_cross_check(parsed_data)
        
        logger.info(f"OCR extraction complete for {os.path.basename(image_path)}")
        
        return parsed_data
        
    except Exception as e:
        logger.error(f"❌ OCR extraction failed: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return _empty_data()


def _ocr_pass_1_high_contrast(img: Image.Image) -> str:
    """OCR Pass 1: High contrast enhancement (best for numbers and dollar amounts)."""
    try:
        # Convert to grayscale
        img_gray = img.convert('L')
        
        # Upscale 2x for better OCR
        width, height = img_gray.size
        img_gray = img_gray.resize((width * 2, height * 2), Image.Resampling.LANCZOS)
        
        # Enhance contrast heavily
        enhancer = ImageEnhance.Contrast(img_gray)
        img_enhanced = enhancer.enhance(3.0)
        
        # Sharpen
        img_enhanced = img_enhanced.filter(ImageFilter.SHARPEN)
        
        # OCR with numeric focus
        custom_config = r'--oem 3 --psm 6 -c tessedit_char_whitelist=0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz$.,()-/:#'
        text = pytesseract.image_to_string(img_enhanced, lang='eng', config=custom_config)
        
        return text.strip()
    except Exception as e:
        logger.warning(f"OCR Pass 1 failed: {e}")
        return ""


def _ocr_pass_2_denoised(img: Image.Image) -> str:
    """OCR Pass 2: Denoised grayscale (best for general text extraction)."""
    try:
        # Convert PIL to OpenCV
        img_cv = cv2.cvtColor(np.array(img), cv2.COLOR_RGB2BGR)
        
        # Convert to grayscale
        gray = cv2.cvtColor(img_cv, cv2.COLOR_BGR2GRAY)
        
        # Upscale 2x
        gray = cv2.resize(gray, None, fx=2, fy=2, interpolation=cv2.INTER_CUBIC)
        
        # Denoise
        denoised = cv2.fastNlMeansDenoising(gray, None, h=10, templateWindowSize=7, searchWindowSize=21)
        
        # Enhance contrast with CLAHE
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
        enhanced = clahe.apply(denoised)
        
        # Convert back to PIL
        img_pil = Image.fromarray(enhanced)
        
        # OCR with default config
        custom_config = r'--oem 3 --psm 6'
        text = pytesseract.image_to_string(img_pil, lang='eng', config=custom_config)
        
        return text.strip()
    except Exception as e:
        logger.warning(f"OCR Pass 2 failed: {e}")
        return ""


def _ocr_pass_3_adaptive(img: Image.Image) -> str:
    """OCR Pass 3: Adaptive thresholding (best for varied lighting/background)."""
    try:
        # Convert PIL to OpenCV
        img_cv = cv2.cvtColor(np.array(img), cv2.COLOR_RGB2BGR)
        
        # Convert to grayscale
        gray = cv2.cvtColor(img_cv, cv2.COLOR_BGR2GRAY)
        
        # Upscale 2x
        gray = cv2.resize(gray, None, fx=2, fy=2, interpolation=cv2.INTER_CUBIC)
        
        # Adaptive threshold
        thresh = cv2.adaptiveThreshold(
            gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2
        )
        
        # Morphological operations to clean up
        kernel = np.ones((1, 1), np.uint8)
        opening = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel)
        
        # Convert back to PIL
        img_pil = Image.fromarray(opening)
        
        # OCR
        custom_config = r'--oem 3 --psm 6'
        text = pytesseract.image_to_string(img_pil, lang='eng', config=custom_config)
        
        return text.strip()
    except Exception as e:
        logger.warning(f"OCR Pass 3 failed: {e}")
        return ""


def _empty_data() -> Dict[str, str]:
    """Return empty data structure for failed extractions."""
    return {
        "Client": "NOTFOUND",
        "Insurance": "NOTFOUND",
        "Date": "NOTFOUND",
        "Service Date": "NOTFOUND",
        "Service Code": "NOTFOUND",
        "Copay": "0",
        "Deductible": "0",
        "Insurance Payment": "NOTFOUND",
        "Paid Amount": "NOTFOUND",
        "Client Responsibility": "NOTFOUND",
        "Patient Amount": "NOTFOUND",
        "Adjustments": "NOTFOUND",
        "Adjustments Amount": "NOTFOUND",
        "Charged Rate": "NOTFOUND",
        "Contracted Rate": "NOTFOUND",
        "Remarks": "",
        "Claim Number": "NOTFOUND",
        "ERA Number": "NOTFOUND",
        "RawText": ""
    }


def _parse_era_text(raw_text: str, combined_text: str = "") -> Dict[str, str]:
    """
    Parse raw OCR text into structured ERA fields.
    Uses combined text from all passes for cross-validation.
    """
    
    data = _empty_data()
    data["RawText"] = raw_text
    
    if not raw_text:
        return data
    
    # Use combined text for better matching
    search_text = combined_text if combined_text else raw_text
    text_upper = search_text.upper()
    
    # === EXTRACT CLAIM NUMBER ===
    claim_patterns = [
        r'CLAIM\s*#?\s*(\d{6,})',
        r'CLAIM\s*NO\.?\s*(\d{6,})',
        r'CLM\s*#?\s*(\d{6,})'
    ]
    for pattern in claim_patterns:
        match = re.search(pattern, text_upper)
        if match:
            data["Claim Number"] = match.group(1)
            break
    
    # === EXTRACT PATIENT NAME ===
    patient_patterns = [
        r'PATIENT[:\s]+([A-Z][a-zA-Z]+(?:\s+[A-Z][a-zA-Z]+){1,3})(?=\s*[-\d]|\s*$)',
        r'PATIENT[:\s]+([A-Z][a-zA-Z\s]{4,40})(?=\s+\d)',
        r'PT[:\s]+([A-Z][a-zA-Z\s]{4,40})(?=\s+\d)',
    ]
    for pattern in patient_patterns:
        match = re.search(pattern, search_text, re.IGNORECASE)
        if match:
            name = match.group(1).strip()
            name = re.sub(r'\s+', ' ', name)
            # Validate: must have at least first and last name
            if len(name.split()) >= 2 and len(name) >= 4:
                data["Client"] = name
                break
    
    # === EXTRACT DATE ===
    date_patterns = [
        r'(\d{1,2}/\d{1,2}/\d{4})',
        r'(\d{1,2}-\d{1,2}-\d{4})',
        r'(\d{4}-\d{1,2}-\d{1,2})'
    ]
    for pattern in date_patterns:
        matches = re.findall(pattern, search_text)
        if matches:
            # Prefer dates that look like service dates (recent)
            data["Date"] = matches[0]
            data["Service Date"] = matches[0]
            break
    
    # === EXTRACT SERVICE CODE ===
    # CPT codes: 90xxx for therapy
    code_match = re.search(r'\b(9\d{4})\b', search_text)
    if code_match:
        data["Service Code"] = code_match.group(1)
    
    # === EXTRACT AMOUNTS (CRITICAL SECTION) ===
    data = _extract_amounts_advanced(search_text, data)
    
    # === EXTRACT REMARK CODES ===
    data["Remarks"] = _extract_remark_codes(text_upper)
    
    return data


def _extract_amounts_advanced(text: str, data: Dict) -> Dict:
    """
    Advanced amount extraction with context awareness.
    Focuses on the data row with amounts, not random numbers in the text.
    """
    
    lines = text.split('\n')
    
    # === STRATEGY: Find the line with Service Date/Code + 4 dollar amounts ===
    # This is the actual data row, not headers or remarks
    
    # Pattern to match dollar amounts with optional parens: $300.00 or ($15.00)
    # MUST have dollar sign OR be in the amounts context
    dollar_amount_pattern = r'\$\s*(\d{1,3}(?:,\d{3})*\.\d{2})|\ (?:\(\$?\s*(\d{1,3}(?:,\d{3})*\.\d{2})\))'
    
    for i, line in enumerate(lines):
        line_upper = line.upper()
        
        # Skip header lines
        if 'CHARGED RATE' in line_upper or 'PATIENT AMOUNT' in line_upper:
            continue
        
        # Skip remark code lines
        if any(x in line_upper for x in ['PR-', 'CO-', 'OA-', 'PI-', 'CLAIM TOTAL']):
            continue
        
        # Look for data lines: has date AND service code AND multiple amounts
        has_date = bool(re.search(r'\d{1,2}[/\-]\d{1,2}[/\-]\d{4}', line))
        has_service_code = bool(re.search(r'\b9\d{4}\b', line))
        
        # Find all amounts on this line (with $)
        dollar_matches = re.findall(r'\$\s*(\d{1,3}(?:,\d{3})*\.\d{2})', line)
        paren_matches = re.findall(r'\(\$?\s*(\d{1,3}(?:,\d{3})*\.\d{2})\)', line)
        
        # Combine: first all dollar amounts, then parenthetical amounts
        all_amounts = dollar_matches + paren_matches
        
        # If this line has date + service code + 4 amounts, it's the data row
        if (has_date or has_service_code) and len(all_amounts) >= 4:
            # Clean amounts
            amounts_clean = [a.replace(',', '').strip() for a in all_amounts[:4]]
            
            try:
                # Validate they're valid numbers
                vals = [float(a) for a in amounts_clean]
                
                # Standard ERA format: Charged, Patient, Adjustments, Paid
                data["Charged Rate"] = amounts_clean[0]
                data["Patient Amount"] = amounts_clean[1]
                data["Client Responsibility"] = amounts_clean[1]
                data["Adjustments Amount"] = amounts_clean[2]
                data["Adjustments"] = amounts_clean[2]
                data["Insurance Payment"] = amounts_clean[3]
                data["Paid Amount"] = amounts_clean[3]
                
                # Success! Break out
                return data
            except:
                continue
    
    # Fallback: Look for "Claim Totals" line (summary row)
    for line in lines:
        if 'CLAIM TOTAL' in line.upper():
            dollar_matches = re.findall(r'\$\s*(\d{1,3}(?:,\d{3})*\.\d{2})', line)
            paren_matches = re.findall(r'\(\$?\s*(\d{1,3}(?:,\d{3})*\.\d{2})\)', line)
            all_amounts = dollar_matches + paren_matches
            
            if len(all_amounts) >= 4:
                amounts_clean = [a.replace(',', '').strip() for a in all_amounts[:4]]
                
                try:
                    vals = [float(a) for a in amounts_clean]
                    
                    data["Charged Rate"] = amounts_clean[0]
                    data["Patient Amount"] = amounts_clean[1]
                    data["Client Responsibility"] = amounts_clean[1]
                    data["Adjustments Amount"] = amounts_clean[2]
                    data["Adjustments"] = amounts_clean[2]
                    data["Insurance Payment"] = amounts_clean[3]
                    data["Paid Amount"] = amounts_clean[3]
                    
                    return data
                except:
                    continue
    
    return data


def _extract_remark_codes(text_upper: str) -> str:
    """Extract and format remark codes (PR, CO, OA, PI)."""
    
    # Fix common OCR errors
    text_fixed = text_upper
    text_fixed = re.sub(r'\b60-', 'CO-', text_fixed)  # 60 misread as CO
    text_fixed = re.sub(r'\bPR(\d)', r'PR-\1', text_fixed)
    text_fixed = re.sub(r'\bCO(\d)', r'CO-\1', text_fixed)
    text_fixed = re.sub(r'\bOA(\d)', r'OA-\1', text_fixed)
    text_fixed = re.sub(r'\bPI(\d)', r'PI-\1', text_fixed)
    
    # Extract remark codes with descriptions
    remark_matches = re.findall(r'(PR|CO|OA|PI)-?\s?(\d+)[:\s]*([^$\n]{0,60})', text_fixed)
    
    if remark_matches:
        remarks = []
        for code, num, desc in remark_matches:
            desc_clean = desc.strip()[:50]  # Truncate descriptions
            if desc_clean:
                remarks.append(f"{code}-{num}: {desc_clean}")
            else:
                remarks.append(f"{code}-{num}")
        
        return " | ".join(remarks)
    
    return ""


def _validate_and_cross_check(data: Dict) -> Dict:
    """
    Self-validation and cross-checking of extracted data.
    Flags suspicious values and attempts corrections.
    """
    
    # Validate all dollar amounts are valid numbers
    amount_fields = [
        "Charged Rate", "Patient Amount", "Client Responsibility",
        "Adjustments Amount", "Adjustments", "Insurance Payment",
        "Paid Amount", "Contracted Rate", "Copay", "Deductible"
    ]
    
    for field in amount_fields:
        value = data.get(field, "")
        if value and value != "NOTFOUND":
            clean = value.replace('$', '').replace(',', '').replace('(', '').replace(')', '').strip()
            try:
                float(clean)
                data[field] = clean
            except ValueError:
                data[field] = "NOTFOUND"
    
    # Cross-check: Patient Amount and Client Responsibility should match
    if (data.get("Patient Amount") != "NOTFOUND" and 
        data.get("Client Responsibility") != "NOTFOUND"):
        if data["Patient Amount"] != data["Client Responsibility"]:
            # Use Patient Amount as authoritative
            data["Client Responsibility"] = data["Patient Amount"]
    
    # Cross-check: Insurance Payment and Paid Amount should match
    if (data.get("Insurance Payment") != "NOTFOUND" and 
        data.get("Paid Amount") != "NOTFOUND"):
        if data["Insurance Payment"] != data["Paid Amount"]:
            # Use Paid Amount as authoritative
            data["Insurance Payment"] = data["Paid Amount"]
    
    return data


# === TESTING ===
if __name__ == "__main__":
    import sys
    
    print("╔" + "═" * 78 + "╗")
    print("║" + " " * 18 + "ENHANCED TESSERACT OCR - STAGE 1" + " " * 28 + "║")
    print("╚" + "═" * 78 + "╝\n")
    
    if len(sys.argv) < 2:
        print("Usage: python ocr_module.py <image_path>")
        print("\nExample:")
        print("  python ocr_module.py ERAexample1.png")
        sys.exit(1)
    
    image_path = sys.argv[1]
    
    print(f"Processing: {image_path}\n")
    print("─" * 80)
    
    result = extract_claim(image_path)
    
    print("\n✅ EXTRACTION COMPLETE\n")
    print("Extracted Data:")
    print("─" * 80)
    
    for key, value in result.items():
        if key != "RawText":
            print(f"  {key:25s}: {value}")
    
    print("\n" + "─" * 80)
    print(f"Raw Text Preview (first 500 chars):")
    print("─" * 80)
    print(result.get('RawText', '')[:500])
    print("─" * 80)



